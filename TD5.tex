\documentclass[french,12pt,a4paper,twoside,openright,titlepage]{report}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[latin1]{inputenc}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{babel}
\usepackage{amsfonts}
\usepackage{graphicx}
%\usepackage{here}
\usepackage{ifthen}
\usepackage{xcomment}
\usepackage{array}
\usepackage{rotating}
\usepackage{multicol}
\textwidth17cm
\textheight25cm
%\oddsidemargin-1cm
%\parskip0.2pt
\voffset-2cm
\hoffset-1cm
\headsep0.5cm
\topmargin1.5cm
\oddsidemargin0.5cm
\evensidemargin0.5cm

\makeatletter
\@addtoreset{section}{part}
\makeatother
\newlength{\mylength}
\newcounter{exo}\stepcounter{exo}
\newcommand\exercice{
\subsubsection*{Exercice \theexo\stepcounter{exo}}
%{\bf Exercice \theexo\stepcounter{exo}\\}
}



\RequirePackage{layout,color}

\definecolor{gray50}{gray}{.5}
\definecolor{gray40}{gray}{.6}
\definecolor{gray30}{gray}{.7}
\definecolor{gray20}{gray}{.8}
\definecolor{gray10}{gray}{.9}
\definecolor{gray05}{gray}{.95}

\newsavebox{\laboiboite}
\newlength{\longdelaboiboite}
\newlength{\deptdelaboiboite}
\newlength{\hautdelaboiboite}
\newcolumntype{R}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }r<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}
\newcolumntype{C}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }c<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}
\newcolumntype{L}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }l<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}

\newcolumntype{S}{>{\begin{lrbox}{\laboiboite}}r<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newcolumntype{D}{>{\begin{lrbox}{\laboiboite}}c<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newcolumntype{M}{>{\begin{lrbox}{\laboiboite}}l<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newlength\Linewidth
\def\findlength{\setlength\Linewidth\linewidth
\addtolength\Linewidth{-4\fboxrule}
\addtolength\Linewidth{-3\fboxsep}
}
\newenvironment{examplebox}{\par\begingroup%
   \setlength{\fboxsep}{5pt}\findlength%
   \setbox0=\vbox\bgroup\noindent%
   \hsize=\Linewidth%
   \begin{minipage}{\Linewidth}\small}%
    {\end{minipage}\egroup%
    \vspace{6pt}%
    \noindent\textcolor{gray20}{\fboxsep2.5pt\fbox%
     {\fboxsep5pt\colorbox{gray05}{\normalcolor\box0}}}%
    \endgroup\par\addvspace{6pt minus 3pt}\noindent%
    \normalcolor\ignorespacesafterend}
\let\Examplebox\examplebox
\let\endExamplebox\endexamplebox


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newboolean{sol}
%\setboolean{sol}{true}
\setboolean{sol}{false}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%M
\ifthenelse{\boolean{sol}}
{
\newenvironment{solution}
{
\begin{examplebox}
\begin{center}
\begin{tabular}{m{0.5cm}|m{15cm}|}\cline{2-2}
%\begin{turn}{90}{Solution}\end{turn}&
\rotatebox{90}{Solution}&
\begin{minipage}[H]{\linewidth}
\vspace{0.2cm}
}
{
\vspace{0.2cm}
\end{minipage}
\\\cline{2-2}
\end{tabular}
\end{center}
\end{examplebox}
}
}
{
\newxcomment[]{solution}
}


\begin{document}

\lhead[ROB3/MAIN3]{ROB3/MAIN3}
\chead[]{}
\rhead[Informatique G\'en\'erale ]{Informatique G\'en\'erale}
 
\ifthenelse{\boolean{sol}}
{
\lfoot[Polytech'Paris-UPMC 2017-2018 (version enseignants)]{Polytech'Paris-UPMC 2017-2018 (version enseignants)}

}
{
\lfoot[Polytech'Paris-UPMC 2017-2018 (version \'etudiants)]{Polytech'Paris-UPMC 2017-2018 (version \'etudiants)}
}

\cfoot[]{}
\rfoot[\thepage]{\thepage}




\pagestyle{fancyplain}
%%%%%%%%%%%%

 %\addcontentsline{toc}{chapter}{S\'erie 1 : Conception d'algorithmes}
 %\chapter{Conception d'algorithmes}
 %\addcontentsline{toc}{chapter}{S\'erie 1 : Conception d'algorithmes}

\chapter*{Travaux Dirigés n°5}

\exercice
Le but de l'exercice est de proposer des fonctions permettant de manipuler des tableaux 2D mais qui seront représentés sous forme
de tableaux 1D en mémoire. On dit qu'on "applatit" le tableau.

Par exemple, le tableau :
\begin{tabular}{|c|c|c|}
\hline
2 & 3 & 4 \\
\hline
5 & 6 & 7 \\
\hline
\end{tabular}

sera représenté en mémoire comme le tableau :
\begin{tabular}{|c|c|c|c|c|c|}
\hline
2 & 3 & 4 & 5 & 6 & 7 \\
\hline
\end{tabular}

\begin{enumerate}
\item Ecrire une fonction \verb|init_tab| qui prend en entrée deux entiers représentant 
le nombre \verb|nl| de lignes et  \verb|nc| de colonne et renvoie 
un tableau de \verb|float| de taille \verb|nl|x\verb|nc| (le tableau étant représenté en mémoire
comme un tableau 1D) dans lequel tous les éléments sont nuls. La fonction renvoie un élément de type pointeur sur \verb|float|
\item Ecrire une fonction \verb|get_in_tab| qui prend (parmi d'autres entrées à déterminer) deux entiers représentant 
les indices en ligne et colonne d'un tableau applati et renvoie la valeur correspondante dans le tableau.
\item Ecrire une fonction \verb|set_in_tab| qui prend (parmi d'autres entrées à déterminer) un \verb|float| \verb|x| et deux entiers représentant 
les indices en ligne et colonne d'un tableau applati et affecte \verb|x| à la valeur correspondante du tableau.
\item Ecrire la fonction \verb|adjacency| qui prend (parmi d'autres entrées à déterminer) un tableau de \verb|float| \verb|Adj| de taille 4 et les indices \verb|i,j| en ligne et colonne d'un tableau applati et renvoie les valeurs des éléments adjacents à l'élément d'indice \verb|i,j|. On appelle élément adjacent, un élement situé à côté (au-dessus, au-dessous, à droite ou à gauche d'un élément de référence).
On pourra proposer deux versions de cette fonction qui traitent différemment les cas où l'élément de référence est au bord du tableau (on pourra soit mettre 0, soit appliquer une condition de périodicité sur les lignes et les colonnes du tableau).
\end{enumerate}


\exercice 
Le but de l'exercice est de proposer des fonctions pour manipuler des nombres complexes à travers l'ensemble de Mandelbrot.
Soit un nombre complexe $c$ définissant un point du plan 
(la partie réelle de $c$ représente l'abscisse, la partie imaginaire représente l'ordonnée).
L'ensemble de Mandelbrot est une fractale définie comme l'ensemble des points $c$ 
du plan complexe pour lesquels la suite de nombres complexes définie par récurrence par :
\begin{equation}
\left\{
\begin{aligned}
z_0 = 0\\
z_{n+1} = z_n^2 + c
\end{aligned}
\right.
\end{equation}
est bornée.

On peut notamment montrer que s'il existe $n$ tel que $|z_n|>2$, la suite est divergente. En pratique, on fixe un nombre maximum d'itération $n_{max}$ pour la suite $z_n$ et on considère que la suite est convergente si $|z_{n_{max}}|<=2$.

\begin{figure}
\centering
\includegraphics[width=.7\textwidth]{./Ensemble_de_Mandelbrot.png}
\caption{Ensemble de Mandelbrot (point noirs)}
\end{figure}

On représentera un nombre complexe comme
deux nombres flottants représentant la partie entière et la partie imaginaire.

\begin{enumerate}
\item Ecrire une fonction

\verb|add(float ar,float ai,float br,float bi, float *p_cr,float *p_ci)|
qui prend deux nombres complexes $a$ et $b$
(avec $a = ar + i.ai$) 
et renvoie le nombre $c=a + b$
(le nombre $c = cr + i.ci$ est modifié par passage par adresse).

\item Ecrire une fonction
 
\verb|mult(float ar,float ai,float br,float bi, float *p_cr,float *p_ci)|
qui prend deux nombres complexes $a$ et $b$
(avec $a = ar + i.ai$) 
et renvoie le nombre $c=a\times b$
(le nombre $c = cr + i.ci$ est modifié par passage par adresse).
\item Ecrire une fonction \verb|module| qui prend en entrée un nombre complexe et renvoie son module
\item Ecrire une fonction \verb|mandelbrot| qui prend en entrée un nombre complexe $c$, un nombre maximum d'itération et renvoie le nombre maximum $n$ d'itération
de la suite de Mandelbrot tel que $|z_n|<=2$
\item On peut reprendre les fonctions ci-dessus en définissant un type \verb|Complexe| composé du champ \verb|real| et \verb|imag|. Les prototypes des fonctions sont alors :
\begin{enumerate}
\item \verb|Complexe add(Complexe a,Complexe b)|
\item \verb|Complexe mult(Complex a,Complexe b)|
\item \verb|float module(Complexe a)|
\item \verb|int mandelbrot(Complexe c, int nmax)|
\end{enumerate}
\end{enumerate}

\end{document}