\documentclass[french,12pt,a4paper,twoside,openright,titlepage]{report}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[latin1]{inputenc}
%\usepackage{fancyheadings}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{babel}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{here}
\usepackage{ifthen}
\usepackage{xcomment}
\usepackage{array}
\usepackage{rotating}

\textwidth17cm
\textheight25cm
%\oddsidemargin-1cm
%\parskip0.2pt
\voffset-2cm
\hoffset-1cm
\headsep0.5cm
\topmargin0.5cm
\oddsidemargin0.5cm
\evensidemargin0.5cm

\makeatletter
\@addtoreset{section}{part}
\makeatother
\newlength{\mylength}
\newcounter{exo}\stepcounter{exo}

\newcommand\exercice[1]{
\subsubsection*{Exercice \theexo\stepcounter{exo} {#1}}
%{\bf Exercice \theexo\stepcounter{exo}\\}
}



\RequirePackage{layout,color}

\definecolor{gray50}{gray}{.5}
\definecolor{gray40}{gray}{.6}
\definecolor{gray30}{gray}{.7}
\definecolor{gray20}{gray}{.8}
\definecolor{gray10}{gray}{.9}
\definecolor{gray05}{gray}{.95}

\newsavebox{\laboiboite}
\newlength{\longdelaboiboite}
\newlength{\deptdelaboiboite}
\newlength{\hautdelaboiboite}
\newcolumntype{R}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }r<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}
\newcolumntype{C}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }c<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}
\newcolumntype{L}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }l<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}

\newcolumntype{S}{>{\begin{lrbox}{\laboiboite}}r<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newcolumntype{D}{>{\begin{lrbox}{\laboiboite}}c<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newcolumntype{M}{>{\begin{lrbox}{\laboiboite}}l<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newlength\Linewidth
\def\findlength{\setlength\Linewidth\linewidth
\addtolength\Linewidth{-4\fboxrule}
\addtolength\Linewidth{-3\fboxsep}
}
\newenvironment{examplebox}{\par\begingroup%
   \setlength{\fboxsep}{5pt}\findlength%
   \setbox0=\vbox\bgroup\noindent%
   \hsize=\Linewidth%
   \begin{minipage}{\Linewidth}\small}%
    {\end{minipage}\egroup%
    \vspace{6pt}%
    \noindent\textcolor{gray20}{\fboxsep2.5pt\fbox%
     {\fboxsep5pt\colorbox{gray05}{\normalcolor\box0}}}%
    \endgroup\par\addvspace{6pt minus 3pt}\noindent%
    \normalcolor\ignorespacesafterend}
\let\Examplebox\examplebox
\let\endExamplebox\endexamplebox



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newboolean{sol}
\setboolean{sol}{false}
%\setboolean{sol}{false}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%M
\ifthenelse{\boolean{sol}}
{
\newenvironment{solution}
{
\begin{examplebox}
\begin{center}
\begin{tabular}{m{0.5cm}|m{15cm}|}\cline{2-2}
%\begin{turn}{90}{Solution}\end{turn}&
\rotatebox{90}{Solution}&
\begin{minipage}[H]{\linewidth}
\vspace{0.2cm}
}
{
\vspace{0.2cm}
\end{minipage}
\\\cline{2-2}
\end{tabular}
\end{center}
\end{examplebox}
}
}
{
\newxcomment[]{solution}
}


\begin{document}

\lhead[ROB3/MAIN3 ]{ROB3/MAIN3 }
\chead[]{}
\rhead[Informatique G\'en\'erale ]{Informatique G\'en\'erale}
 
\ifthenelse{\boolean{sol}}
{
\lfoot[Polytech'Paris-UPMC 2017-2018 (version enseignants)]{Polytech'Paris-UPMC 2017-2018 (version enseignants)}

}
{
\lfoot[Polytech'Paris-UPMC 2017-2018 (version \'etudiants)]{Polytech'Paris-UPMC 2017-2018 (version \'etudiants)}
}

\cfoot[]{}
\rfoot[\thepage]{\thepage}




\pagestyle{fancyplain}
%%%%%%%%%%%%

 %\addcontentsline{toc}{chapter}{S\'erie 1 : Conception d'algorithmes}
 %\chapter{Conception d'algorithmes}
 %\addcontentsline{toc}{chapter}{S\'erie 1 : Conception d'algorithmes}

\chapter*{Travaux Dirigés n°1}
Pour chaque problème, il vous est demand\'e de d\'efinir clairement :
\begin{itemize}
\item  les donn\'ees d'entr\'ee du problème en pr\'ecisant leurs  types (nombre entier, r\'eel, ...) ;
\item les \'eventuelles  donn\'ees de sortie  du problème en pr\'ecisant leurs types ;
\item les instructions permettant d'obtenir les donn\'ees de sortie à partir des donn\'ees d'entr\'ee.
\end{itemize}

Tester ensuite votre algorithme \`a la main à partir de donn\'ees d'entr\'ees judicieusement choisies pour explorer les diff\'erents cas de fonctionnement. Prenons à titre  d'exemple le calcul  de la valeur absolue d'un nombre entier \verb x. Un algorithme est :

\begin{algorithm}[h!]
\caption{Algorithme de d\'etermination de la valeur absolue d'un nombre entier $x$}
\label{algo_cm}
\begin{algorithmic}[1]
\REQUIRE{x, nombre entier}
\ENSURE{valeur\_absolue, nombre entier}
\IF{$x \ge 0$}
\STATE $valeur\_absolue \leftarrow x$
\ELSE
		\STATE $valeur\_absolue \leftarrow -x$
\ENDIF
\RETURN $valeur\_absolue$
\end{algorithmic}
\end{algorithm}

 

Tester cet algorithme en prenant successivement comme donn\'ee d'entr\'ee un entier positif, un entier n\'egatif et z\'ero. \\
Cette d\'emarche doit être reproduite pour chaque algorithme d\'evelopp\'e.



\exercice{}
Que fait ce petit algorithme ? 

\begin{algorithmic}[1]
\REQUIRE{$x$,$y$, nombres entiers}
\ENSURE{$test$, nombre booléen}
\IF{$x \le 0$ ou $y \le 0$}
\STATE $test \leftarrow 0 $
\ELSE
\STATE  $test \leftarrow 1$
\ENDIF
\RETURN test
\end{algorithmic}

\exercice{}
Ecrire une s\'equence d'instructions permettant de d\'eterminer le minimum de deux nombres entiers x et y. Le maximum.

\begin{solution}
%\begin{algorithm}[h!]
%\caption{Minimum de deux chiffres}
%\label{algo_cm}
\begin{algorithmic}[1]
\REQUIRE{$x$,$y$, nombre entier}
\ENSURE{$valeur\_min$, nombre entier}
\IF{$x \le y$}
\STATE $valeur\_min\leftarrow x$
\ELSE
		\STATE  $valeur\_min\leftarrow y$
\ENDIF
\RETURN $valeur\_min$
\end{algorithmic}
%\end{algorithm}
\end{solution}





\exercice{}
Ecrire l'algorithme permettant d'énumérer les diviseurs d'un entier $n$.
\begin{solution}

On propose 2 versions.

La solution naïve :
\begin{algorithmic}[1]
\REQUIRE{$n$ entier}
\ENSURE{rien(affichage)}\\
\hspace{-22pt}
\noindent {\bf Donn\'ees locales : } variable de boucle $i$.
\\
\PRINT{1}
\FOR{$i$ allant de 2 \`a $n$}
\IF{$n$ mod $i = 0$}
\PRINT{$i$}
\ENDIF
\ENDFOR
\PRINT{$n$}
\end{algorithmic}

Si on suppose l'existence d'une fonction \verb|sqrt| pour les entiers qui renvoie
la valeur entière de la racine carrée, on peut écrire (pour réduire le nombre d'appel
au modulo)  :
\begin{algorithmic}[1]
\REQUIRE{$n$ entier}
\ENSURE{rien(affichage)}\\
\hspace{-22pt}
\noindent {\bf Donn\'ees locales : } variable de boucle $i$.
\\
\PRINT{1, n}
\FOR{$i$ allant de 2 \`a sqrt($n$)}
\IF{$n$ mod $i = 0$}
\PRINT{$i$,$n/i$}

\ENDIF
\ENDFOR

\end{algorithmic}
Notons que, dans cette seconde version, les diviseurs ne sont plus affichés dans l'ordre croissant.
\end{solution}
\exercice{- Nombres parfaits}
Un nombre parfait est un nombre positif égal à la somme de ses diviseurs (par 
exemple, 6 est un nombre parfait). Ecrire un algorithm qui 
renvoie 1 si l'entier transmis en arguments est parfait, 0 sinon. 
\begin{solution}
\begin{algorithmic}[1]
\REQUIRE{$x$ entier}
\ENSURE{boolean}\\
\hspace{-22pt}
\noindent {\bf Donn\'ees locales : } variable de boucle $i$, variable $somme$.
\\
\STATE  $somme \leftarrow 0$
\FOR{$i$ allant de 1 \`a $x$}
\IF{$x$ mod $i = 0$}
\STATE  $somme \leftarrow somme + i$
\ENDIF
\ENDFOR
\IF{somme = x}
\RETURN $1$
\ELSE
\RETURN $0$
\ENDIF
\end{algorithmic}
\end{solution}

\exercice{- Inversion de variables}

\'Ecrire un algorithme qui prend en entr\'ee deux variables enti\`eres {\tt a} et {\tt b} et qui inverse
leurs contenus.
Vous pouvez faire deux versions, l'une en utilisant une variable locale et sans utiliser de variable locale.

\begin{solution}
\begin{algorithmic}[1]
\REQUIRE{$a$ et $b$ entiers}
\ENSURE{inverse les contenus}
\\
\STATE $a \leftarrow a+b$
\STATE $b \leftarrow a-b$
\STATE $a \leftarrow a-b$
\end{algorithmic}
\end{solution}

\exercice{- Algorithme d'Euclide}


\'Ecrire un algorithme qui calcule le {\tt PGCD} de deux nombres entiers strictement positifs en utilisant
l'algorithme d'Euclide.

On rappelle le principe \`a la base de cet algorithme :

%$$ {\tt PGCD}(a,b) = {\tt PGCD}(b,a \mod b) \quad \hbox{et} \quad {\tt PGCD}(a,1) = a $$
\begin{itemize}
\item on note $q$ et $r$ le quotient et le reste de la division
  euclidienne de $a$ par $b$ tels que $a=b \times q + r$
\item Si $r=0$ alors ${\tt PGCD}(a,b)=b$ (Ca veut dire que $b$ divise
  $a$).
\item Si $r>0$ alors ${\tt PGCD}(a,b)={\tt PGCD}(b,r)$
\end{itemize}
\begin{solution}
NB : inutile de traiter le cas $a<b$, car dans ce cas la première
division euclidienne a uniquement pour effet d'inverser a et b.
\begin{algorithmic}[1]
\REQUIRE{$a$ et $b$ entiers strictement positifs}
\ENSURE{$pgcd$ le {\tt PGCD} de ces deux nombres}
\\
\WHILE{$b > 0$}
\STATE $a \leftarrow a \mod b$
\STATE Inverser $a$ et $b$
\ENDWHILE
\STATE $pcgd \leftarrow a$
\RETURN $pgcd$
\end{algorithmic}
\end{solution}

\exercice {- Fractions \'egyptiennes}

Toute fraction peut s'\'ecrire comme une somme de fractions différentes deux à deux et ayant $1$ comme num\'erateur.
Cette d\'ecomposition est appel\'ee d\'ecomposition en fractions \'egyptiennes.
En voici un exemple :
$$ \frac{7}{8} = \frac{1}{2} + \frac {1}{3} + \frac{1}{24} $$
\'Ecrire un algorithme prenant en entr\'ee le num\'erateur $n$ et le d\'enominateur $d$ d'une fraction
et affiche sa d\'ecomposition en fractions \'egyptiennes.

\begin{solution}
\begin{algorithmic}[1]
\REQUIRE{$n$ et $d$ entiers, num\'erateur et d\'enominateur de la fraction $\frac{n}{d}$}
\ENSURE{affiche la d\'ecomposition en fractions \'egyptiennes}\\
\hspace{-22pt}
\noindent {\bf Donn\'ees locales : } variable de boucle $i$.
\\
\STATE $i \leftarrow 2$
\WHILE{ $ i\cdot n \neq d $ }
\IF{ $i\cdot n \geq d$ }
\STATE Afficher `` $\frac{1}{i} +$ ''
\STATE $a \leftarrow i\cdot n - d$
\STATE $b \leftarrow i\cdot d$
\ENDIF
\STATE $i \leftarrow i+1$
\ENDWHILE
\STATE Afficher `` $\frac{1}{i}$ ''
\end{algorithmic}
\end{solution}



\exercice{}
%\subsection{Calcul de $n^m$ et $n!$}
Ecrire l'algorithme permettant de calculer $n^m$ (n et m entiers positifs ou nuls).

\begin{solution}
%\begin{algorithm}[h!]
%\caption{Calcul de $n^m$ }
%\label{algo_cm}
\begin{algorithmic}[1]
\REQUIRE{$n$, $m$ : entiers}
\ENSURE{$res$ : entier}
\IF{$m = 0$}
\STATE Retourner(1)
\ENDIF 
\IF{$n = 0$}
\STATE Retourner(0)
\ENDIF 
\STATE $res \leftarrow 1$
\FOR{$i=1$ \`a $m$ avec un pas de 1}
\STATE $res \leftarrow res \times n$
\ENDFOR
\RETURN $res$
\end{algorithmic}
%\end{algorithm}
\end{solution}


%\exercice{}
%%\subsection{Calcul de l'heure d'arriv\'ee d'un train}
%Ecrire l'algorithme  permettant de calculer l'heure d'arriv\'ee d'un train, connaissant son heure de
%d\'epart ainsi que le temps de trajet n\'ecessaire. L'heure de d\'epart est mod\'elis\'ee sous la forme d'un triplet d'entiers $(h_d,m_d,s_d)$ avec 
%\begin{itemize}
%\item $h_d$ : heure de d\'epart ($0\le h_d\le 23$)
%\item $m_d$ : minutes de d\'epart  ($0\le m_d \le 59$)
%\item $s_d$ : secondes de d\'epart  ($0\le s_d\le59$)
%\end{itemize}
%De la m\^eme mani\`ere le temps de trajet et l'heure d'arriv\'ee sont respectivement mod\'elis\'es sous la forme de triplets d'entiers $(h_t,m_t,s_t)$ et $(h_a,m_a,s_a)$ 
%
%\begin{solution}
%%\begin{algorithm}[h!]
%%\caption{Calcul de l'heure d'arriv\'ee d'un train}
%%\label{algo_cm}
%\begin{algorithmic}[1]
%\REQUIRE{$h_d$, $m_d$, $s_d$, $h_t$, $m_t$ , $s_t$ : entiers}\\
%\COMMENT{$h_d$, $m_d$, $s_d$ : heure de départ}\\
%\COMMENT{$h_t$, $m_t$, $s_t$ : temps de parcours}
%\ENSURE{$j_a$, $h_a$,$m_a$, $d_a$ : entiers}
%\COMMENT{heure d'arrivée}
%\STATE \COMMENT{Utilisation d'une variable  suppl\'ementaire temporaire :  $j_a$ (=1 si le train arrive le lendemain)}
%\STATE  $s_a \leftarrow 0$
%\STATE  $m_a \leftarrow 0$
%\STATE  $h_a \leftarrow 0$
%\STATE  $j_a \leftarrow 0$
%\STATE  $s_a \leftarrow s_d +s_t$
%\IF{$s_a \ge 60$}
%\STATE $s_a \leftarrow s_a-60$
%\STATE $m_a \leftarrow  1$
%\ENDIF
%\STATE  $m_a \leftarrow m_d+m_t$
%\IF{$m_a \ge 60$}
%\STATE $m_a \leftarrow m_a-60$
%\STATE $ha \leftarrow  1$
%\ENDIF
%\STATE  $h_a \leftarrow h_d+h_t$
%\IF{$h_a \ge 24$}
%\STATE $h_a \leftarrow h_a-24$
%\STATE $j_a \leftarrow  1$
%\ENDIF
%\RETURN $(j_a,h_a,m_a,d_a)$
%\end{algorithmic}
%%\end{algorithm}
%
%On peut aussi utiliser la division enti\`ere et l'op\'erateur modulo.
%\end{solution}


\end{document}
