\documentclass[french,12pt,a4paper,twoside,openright,titlepage]{report}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[latin1]{inputenc}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{babel}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{here}
\usepackage{ifthen}
\usepackage{xcomment}
\usepackage{array}
\usepackage{rotating}

\textwidth17cm
\textheight25cm
%\oddsidemargin-1cm
%\parskip0.2pt
\voffset-2cm
\hoffset-1cm
\headsep0.5cm
\topmargin0.5cm
\oddsidemargin0.5cm
\evensidemargin0.5cm

\makeatletter
\@addtoreset{section}{part}
\makeatother
\newlength{\mylength}
\newcounter{exo}\stepcounter{exo}

\newcommand\exercice[1]{
\subsubsection*{Exercice \theexo\stepcounter{exo} {#1}}
%{\bf Exercice \theexo\stepcounter{exo}\\}
}



\RequirePackage{layout,color}

\definecolor{gray50}{gray}{.5}
\definecolor{gray40}{gray}{.6}
\definecolor{gray30}{gray}{.7}
\definecolor{gray20}{gray}{.8}
\definecolor{gray10}{gray}{.9}
\definecolor{gray05}{gray}{.95}

\newsavebox{\laboiboite}
\newlength{\longdelaboiboite}
\newlength{\deptdelaboiboite}
\newlength{\hautdelaboiboite}
\newcolumntype{R}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }r<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}
\newcolumntype{C}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }c<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}
\newcolumntype{L}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }l<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}

\newcolumntype{S}{>{\begin{lrbox}{\laboiboite}}r<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newcolumntype{D}{>{\begin{lrbox}{\laboiboite}}c<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newcolumntype{M}{>{\begin{lrbox}{\laboiboite}}l<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newlength\Linewidth
\def\findlength{\setlength\Linewidth\linewidth
\addtolength\Linewidth{-4\fboxrule}
\addtolength\Linewidth{-3\fboxsep}
}
\newenvironment{examplebox}{\par\begingroup%
   \setlength{\fboxsep}{5pt}\findlength%
   \setbox0=\vbox\bgroup\noindent%
   \hsize=\Linewidth%
   \begin{minipage}{\Linewidth}\small}%
    {\end{minipage}\egroup%
    \vspace{6pt}%
    \noindent\textcolor{gray20}{\fboxsep2.5pt\fbox%
     {\fboxsep5pt\colorbox{gray05}{\normalcolor\box0}}}%
    \endgroup\par\addvspace{6pt minus 3pt}\noindent%
    \normalcolor\ignorespacesafterend}
\let\Examplebox\examplebox
\let\endExamplebox\endexamplebox

\widowpenalty 10000
\clubpenalty 10000
\raggedbottom

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newboolean{sol}
\setboolean{sol}{false}
%\setboolean{sol}{false}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%M
\ifthenelse{\boolean{sol}}
{
\newenvironment{solution}
{
\begin{examplebox}
\begin{center}
\begin{tabular}{m{0.5cm}|m{15cm}|}\cline{2-2}
%\begin{turn}{90}{Solution}\end{turn}&
\rotatebox{90}{Solution}&
\begin{minipage}[H]{\linewidth}
\vspace{0.2cm}
}
{
\vspace{0.2cm}
\end{minipage}
\\\cline{2-2}
\end{tabular}
\end{center}
\end{examplebox}
}
}
{
\newxcomment[]{solution}
}


\begin{document}

\lhead[ROB3 ]{ROB3 }
\chead[]{}
\rhead[Informatique G\'en\'erale ]{Informatique G\'en\'erale}
 
\ifthenelse{\boolean{sol}}
{
\lfoot[Polytech'Paris-UPMC 2015-2016 (version enseignants)]{Polytech'Paris-UPMC 2015-2016 (version enseignants)}

}
{
\lfoot[Polytech'Paris-UPMC 2015-2016 (version \'etudiants)]{Polytech'Paris-UPMC 2015-2016 (version \'etudiants)}
}

\cfoot[]{}
\rfoot[\thepage]{\thepage}




\pagestyle{fancyplain}
%%%%%%%%%%%%

 %\addcontentsline{toc}{chapter}{S\'erie 1 : Conception d'algorithmes}
 %\chapter{Conception d'algorithmes}
 %\addcontentsline{toc}{chapter}{S\'erie 1 : Conception d'algorithmes}

\chapter*{Travaux Pratiques n°3}

\exercice {}

Ecrire un aglorithme récursif qui écrit l'écriture inverse d'un entier donné en entrée. (par exemple si on entre-2344, on obtiendra l'affichage -4432).
\begin{solution}
\begin{verbatim}
#include <stdio.h>

void inversion (int nb);

void inversion (int nb)
{
  if (nb < 0)
    {
      printf("-");
      return inversion (-nb);
    }
  if (nb < 10)
    {
      printf("%d",nb);
    }
  else 
    {
      printf ("%d",nb % 10);
      return inversion (nb/10);
    }
}

int main(void)
{
  int nb;
  printf ("Entrer un nombre\n");
  scanf ("%d",&nb);
  
  inversion (nb);
  printf("\n");
  return 0;
}
\end{verbatim}
\end{solution}

<<<<<<< HEAD:TP4.tex
\exercice{Problème "Couicable".}
\begin{enumerate}
\item Ecrire une fonction {\tt nbDeChiffres(x)} qui retourne le nombre de 
chiffres composant un entier $x$ transmis en arguments
=======
\exercice{}

Ecrire et tester une fonction \texttt{void init\_tab(int max, int tab[], int n)} qui initialise les n premiers éléments du tableau d'entiers \texttt{tab} à des valeurs aléatoires comprises entre \texttt{0} et \texttt{max-1}. Si le tableau est de taille \texttt{n}, la fonction initialisera l'ensemble des éléments de \texttt{tab}. 

\exercice {}
Ecrire une fonction \verb|void ech(int tab[],int i, int j)| qui échange l'élément d'indice i et l'élément d'indice j dans le tableau \verb|tab|.


\exercice{(Tri par sélection)}

Ecrire et tester une fonction C  \texttt{void tri\_selec(int tab[], int n)} qui implémente l'algorithme de tri par sélection vu en TD. \verb|n| représente le nombre d'éléments à trier.


>>>>>>> 91b186a62cd629e3363f2edee3173a77f26825f0:TP3.tex
\begin{solution}
\begin{verbatim}
int nbDeChiffres(int x){
   int nbChiffres=0;
   if (x == 0) // cas delicat : x est le nombre 0
      return 1;
   else {
      while (x > 0) {
         nbChiffres ++;
         x /= 10;
      }
      return nbChiffres;
   }
}
\end{verbatim}
\end{solution}

<<<<<<< HEAD:TP4.tex
\item Ecrire une fonction {\tt extraitNombre(x,n,lg)} qui extrait de $x$ entier positif, à 
partir du nième chiffre en partant de la droite, le nombre composé de $lg$ 
chiffres. Elle renvoie -1 si les entrées ne sont pas correctes.\\
Exemple 1, {\tt extraitNombre(45863047,4,3)} renvoie 586.\\
Exemple 2, {\tt extraitNombre(45863047,6,4)} renvoie -1.\\
=======

\exercice{(Tri à bulle)}

Ecrire une fonction C  \texttt{void tri\_bulle(int tab[], int n)}qui implémente l'algorithme de tri à bulle.  \verb|n| représente le nombre d'éléments à trier.

Le principe du tri à bulle est de comparer successivement tous les éléments adjacents d'un tableau (en commençant par le premier) et de les échanger si 
l'élément d'indice $i$ est supérieur à l'élément d'indice $i+1$. On recommence cette opération tant que tous les éléments ne sont pas triés.
>>>>>>> 91b186a62cd629e3363f2edee3173a77f26825f0:TP3.tex

\begin{solution}
{\scriptsize
\begin{verbatim}
int extraitNombre(int x, int n, int lg){
   int puiss=1;

   // Etape 0 : verifier que l'operation est realisable (etape facultative)
   if ((n > nbDeChiffres(x)) || (lg > nbDeChiffres(x)) || ((n+lg) > nbDeChiffres(x)))
      return -1;
   if (n<0 || x<0 || log <0)
      return -1;

   // Etape 1 : enlever les n derniers chiffres de x
   while (n>0) {
      x /= 10;
      n --;
   }

   // Etape 2 : garder les lg derniers chiffres du "nouveau" x
   while (lg > 0) {
      puiss *= 10;
      lg --;
   } 
   x %= puiss;
   return x;
} 
\end{verbatim}
}
\end{solution}

<<<<<<< HEAD:TP4.tex
\item Ecrire une fonction {\tt estPair(x)} qui renvoie 1 si le nombre de chiffres de $x$ est pair, 0 sinon.
\begin{solution}
\begin{verbatim}
int estPair(x){
   if ((nbDeChiffres(x) % 2) == 0) 
      return 1;
   else return 0;
}
\end{verbatim}
=======

\exercice{(Tri par insertion)}
Ecrire une fonction C  \texttt{void tri\_bulle(int tab[], int n)}qui implémente l'algorithme de tri par insertion.  \verb|n| représente le nombre d'éléments à trier.

Le tri par insertion consiste à prendre l'élément se trouvant juste après la partie 
déjà triée du tableau et de trouver sa place dans cette dernière (insertion). Le premier élément 
à insérer est le deuxième élément du tableau, le premier étant forcément déjà  trié puisqu'il 
est tout seul. On recommence ce procédé jusqu'au dernier élément du tableau.
\begin{solution}
\begin{verbatim}
void tri_insert(int tab[],int n) {
  int p;
  int j;
  int k;
  for (j=1;j<n;j++) {
    p=tab[j];
    k=j-1;
    while(k>=0 && tab[k]>p)
      {
	tab[k+1]=tab[k];
	k--;
      }
      tab[k+1]=p;

  }
}
\end{verbatim}

>>>>>>> 91b186a62cd629e3363f2edee3173a77f26825f0:TP3.tex
\end{solution}

\exercice{(Duplication de tableaux)}
Ecrire un programme C  \texttt{void copy\_tab(int tabin[], int tabout[], int n)} qui copie les \verb|n| premières
valeurs
du tableau \verb|tabin| dans le tableau \verb|tabout|.


<<<<<<< HEAD:TP4.tex
\item Ecrire une fonction {\tt sommeDesChiffres(x)} qui renvoie la somme des 
chiffres composant le nombre $x$ transmis en arguments
\begin{solution}
=======
Pour mesurer le temps (en secondes) d'exécution d'une séquence d'instruction, on utilise la bibliothèque \texttt{time.h}. On déclare une variable \texttt{p} de type \texttt{double} et deux variables \texttt{start} et \texttt{end} de type \texttt{clock\_t} :
\begin{verbatim}
double p;
clock_t start, end ;
\end{verbatim}
 Au début et à la fin de la séquence d'instruction (ici séquence permettant de trier le tableau), on consulte l'horloge de l'ordinateur :
>>>>>>> 91b186a62cd629e3363f2edee3173a77f26825f0:TP3.tex
\begin{verbatim}
int sommeDesChiffres(int x){
   int somme=0;

   while (x > 0) {
      somme += x%10;
      x /= 10;
   }
   return somme;
}
\end{verbatim}
\end{solution}

\item Un nombre $x$ est dit couicable si la somme des chiffres de sa partie 
droite est égale à la somme des chiffres de sa partie gauche. Le nombre de 
chiffres composant le nombre étudié doit être pair.Par exemple, 256823 est 
couicable. Ecrire la fonction {\tt estCouicable(x)} qui affiche si $x$, 
transmis en arguments, est un nombre couicable ou non.  
\begin{solution}
{\footnotesize
\begin{verbatim}
void estCouicable(int x){
   int gauche, droite, nbChiffres, puiss=1;

   if (!estPair(x))
      printf("\n%d n'est pas couicable : nombre de chiffres impair",x);
   else {
      // On reccupere les parties droite et gauche de x
      nbChiffres = nbDeChiffres(x);
      droite = extraitNombre(x,0,nbChiffres/2);
      gauche = extraitNombre(x,nbChiffres/2,nbChiffres/2);
      if (sommeDesChiffres(droite) != sommeDesChiffres(gauche))
         printf("\n%d n'est pas couicable",x);
      else
         printf("\n%d est couicable",x);
   }
}
\end{verbatim}
}
\end{solution}
\end{enumerate}

\exercice{}
Ecrire une fonction qui prend en entrée deux chaînes de caractères \verb|s1| et \verb|s2| et modifie \verb|s1| de façon à supprimer la sous-chaîne \verb|s2|. Si \verb|s2| n'est pas incluse dans \verb|s1|, la fonction de modifie pas \verb|s1|. Si \verb|s2| est présent plusieurs fois dans \verb|s1|, on supprime chaque occurence.

\exercice{}
Les parenthèses permettent, par exemple, de changer la priorité des opérations dans une expression algébrique.
Ex : $(a+2*(x-y))*(b+2)$. Si les parenthèses permettent de définir une expression algébrique valide, on dit alors que l'expression est bien parenthésée. Dans la cas contraire, l'expression est dite mal parenthésée. Le but de cet exercice est d'écrire un programme permettant de tester la validité des parenthèses dans une expression algébrique.
\begin{enumerate}
\item Une expression est considérée comme une chaîne de caractères. Un première étape est de supprimer les caractères de l'expression. Par exemple l'expression donnée précédemment devient : $(())()$.  Ecrire une fonction prenant en entrée une expression algébrique, et renvoyant un tableau de caractères ne contenant que les parenthèses (ce tableau sera un tableau statique passé en entrée qui sera modifié par la fonction). \\
\item Dites si les expressions suivantes sont bien ou mal parenthésées. Dans le cas ou elles sont mal parenthésées, expliquez pourquoi :
\begin{itemize}
\item $()(())$
\item $()))$
\item $())(()$
\end{itemize}
\item Proposez une fonction prenant en entrée un tableau de caractères ne contenant que des parenthèses et renvoyant 1  si l'expression est bien parenthésée et 0 si elle est mal parenthésée.\\
\item Proposez une fonction prenant en entrée un tableau de caractères T ne contenant que des parenthèse et renvoyant la plus longue expression bien parenthésée contenue dans T.\\

\end{enumerate}


\exercice{}

Le problème des tours de Hanoï est un jeu de réflexion imaginé par le mathématicien français Édouard Lucas, et consistant à déplacer des disques de diamètres différents d'une tour de « départ » à une tour d'« arrivée » en passant par une tour « intermédiaire » et ceci en un minimum de coups, tout en respectant les règles suivantes :
\begin{itemize}
    \item on ne peut déplacer plus d'un disque à la fois,
    \item  on ne peut placer un disque que sur un autre disque plus grand que lui ou sur un emplacement vide.
\end{itemize}
On suppose que cette dernière règle est également respectée dans la configuration de départ.
On suppose que les trois positions des trois tours sont numérotées 1, 2 et 3.

Ecrire la fonction qui prend en entrée $n$ le nombre de disque sur
la tour, $dep$ la position de la tour de départ, $med$ la position de
la tour intermédiaire, et $fin$ la position finale. Cette fonction ne renvoie rien mais  affiche les déplacement successifs sous forme d'un couple d'entier $(a,b)$ qui signifie qu'on déplace le disque au dessus de la tour $a$ sur la tour $b$.

Exemple : les mouvements nécessaires pour déplacer 3 disques de $1$ vers $3$ en passant par $2$ :
\begin{itemize}
\item (1,3)
\item (1,2)
\item (3,2)
\item (1,3)
\item (2,1)
\item (2,3)
\item (1,3)
\end{itemize}

<<<<<<< HEAD:TP4.tex
\begin{solution}
\begin{verbatim}
void deplace(int n, int dep,int med,int fin)
{
if (n==1) printf("(%d,%d)\n",dep,fin);
if (n>1) {
	deplace (n-1,dep,fin,med);
	printf("(%d,%d)\n",dep,fin);
	deplace (n-1,med,dep,fin);
	 }
}
=======
%Le temps d'execution du tri par shell est : 0.020000
>>>>>>> 91b186a62cd629e3363f2edee3173a77f26825f0:TP3.tex

\end{verbatim}
\end{solution}

\end{document}
