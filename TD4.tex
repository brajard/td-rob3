\documentclass[french,12pt,a4paper,twoside,openright,titlepage]{report}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[latin1]{inputenc}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{babel}
\usepackage{amsfonts}
\usepackage{graphicx}
%\usepackage{here}
\usepackage{ifthen}
\usepackage{xcomment}
\usepackage{array}
\usepackage{rotating}
\usepackage{multicol}
\textwidth17cm
\textheight25cm
%\oddsidemargin-1cm
%\parskip0.2pt
\voffset-2cm
\hoffset-1cm
\headsep0.5cm
\topmargin0.5cm
\oddsidemargin0.5cm
\evensidemargin0.5cm

\makeatletter
\@addtoreset{section}{part}
\makeatother
\newlength{\mylength}
\newcounter{exo}\stepcounter{exo}
\newcommand\exercice{
\subsubsection*{Exercice \theexo\stepcounter{exo}}
%{\bf Exercice \theexo\stepcounter{exo}\\}
}



\RequirePackage{layout,color}

\definecolor{gray50}{gray}{.5}
\definecolor{gray40}{gray}{.6}
\definecolor{gray30}{gray}{.7}
\definecolor{gray20}{gray}{.8}
\definecolor{gray10}{gray}{.9}
\definecolor{gray05}{gray}{.95}

\newsavebox{\laboiboite}
\newlength{\longdelaboiboite}
\newlength{\deptdelaboiboite}
\newlength{\hautdelaboiboite}
\newcolumntype{R}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }r<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}
\newcolumntype{C}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }c<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}
\newcolumntype{L}{>{\begin{lrbox}{\laboiboite} 
$\displaystyle }l<{$\end{lrbox}%
    \settowidth{\longdelaboiboite}{\usebox{\laboiboite}}%
    \settoheight{\hautdelaboiboite}{\usebox{\laboiboite}}%
    \settodepth{\deptdelaboiboite}{\usebox{\laboiboite}}%
    \addtolength{\hautdelaboiboite}{\deptdelaboiboite}%
    \addtolength{\hautdelaboiboite}{2ex}%
    \parbox[c][\hautdelaboiboite][c]{0cm}{} \makebox[\width]
{\usebox{\laboiboite}}}}

\newcolumntype{S}{>{\begin{lrbox}{\laboiboite}}r<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newcolumntype{D}{>{\begin{lrbox}{\laboiboite}}c<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newcolumntype{M}{>{\begin{lrbox}{\laboiboite}}l<{\end{lrbox}%
    \mbox{\usebox{\laboiboite}}}}
\newlength\Linewidth
\def\findlength{\setlength\Linewidth\linewidth
\addtolength\Linewidth{-4\fboxrule}
\addtolength\Linewidth{-3\fboxsep}
}
\newenvironment{examplebox}{\par\begingroup%
   \setlength{\fboxsep}{5pt}\findlength%
   \setbox0=\vbox\bgroup\noindent%
   \hsize=\Linewidth%
   \begin{minipage}{\Linewidth}\small}%
    {\end{minipage}\egroup%
    \vspace{6pt}%
    \noindent\textcolor{gray20}{\fboxsep2.5pt\fbox%
     {\fboxsep5pt\colorbox{gray05}{\normalcolor\box0}}}%
    \endgroup\par\addvspace{6pt minus 3pt}\noindent%
    \normalcolor\ignorespacesafterend}
\let\Examplebox\examplebox
\let\endExamplebox\endexamplebox


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newboolean{sol}
%\setboolean{sol}{true}
\setboolean{sol}{false}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%M
\ifthenelse{\boolean{sol}}
{
\newenvironment{solution}
{
\begin{examplebox}
\begin{center}
\begin{tabular}{m{0.5cm}|m{15cm}|}\cline{2-2}
%\begin{turn}{90}{Solution}\end{turn}&
\rotatebox{90}{Solution}&
\begin{minipage}[H]{\linewidth}
\vspace{0.2cm}
}
{
\vspace{0.2cm}
\end{minipage}
\\\cline{2-2}
\end{tabular}
\end{center}
\end{examplebox}
}
}
{
\newxcomment[]{solution}
}


\begin{document}

\lhead[ROB3]{ROB3}
\chead[]{}
\rhead[Informatique G\'en\'erale ]{Informatique G\'en\'erale}
 
\ifthenelse{\boolean{sol}}
{
\lfoot[Polytech'Paris-UPMC 2015-2016 (version enseignants)]{Polytech'Paris-UPMC 2015-2016 (version enseignants)}

}
{
\lfoot[Polytech'Paris-UPMC 2015-2016 (version \'etudiants)]{Polytech'Paris-UPMC 2015-2016 (version \'etudiants)}
}

\cfoot[]{}
\rfoot[\thepage]{\thepage}




\pagestyle{fancyplain}
%%%%%%%%%%%%

 %\addcontentsline{toc}{chapter}{S\'erie 1 : Conception d'algorithmes}
 %\chapter{Conception d'algorithmes}
 %\addcontentsline{toc}{chapter}{S\'erie 1 : Conception d'algorithmes}

\chapter*{Travaux Dirigés n°4}
\exercice {} 
Ecrire l'algorithme qui compte le nombre de déplacements effectués par
la tête de lecture/écriture d'une
machine de Turing avant qu'elle ne s'arrête. On considère une machine
de Turing à 5 états de 0 à 4 et un état particulier -1 qui arrête la
machine.
La machine peut lire ou écrire uniquement des 0 ou des 1 sur le ruban.
On modélise la machine de
Turing de la façon suivante
\begin{itemize}
\item Un tableau d'entiers \texttt{ruban} de taille 100 qui représente le ruban
  (normalement infini). \texttt{ruban} sera
  initialisé avec que des zéros.\\
\item Un entier \texttt{pos} représentant la position du curseur sur le
tableau \texttt{ruban}. \texttt{pos} sera initialisé à $50$.\\
\item Un entier \texttt{cstate} représentant l'état courant de la
  machine. \texttt{cstate} sera initalisé à 0.
\item Un tableau d'entiers \texttt{write0} (resp. \texttt{write1}) de taille 5
  qui donne la valeur à écrire sur le ruban de la machine dans le cas
  où on lit un 0 (resp. 1). Par exemple, si la machine lit un 0 sur le
  ruban, et que son état courant est 3, alors on effectue l'affectation
  suivante : \texttt{ruban[pos]=write1[3];}. Notez que les tableaux
  \texttt{write0} et \texttt{write1} ne contiennent que des 0 ou des 1.\\
\item Un tableau d'entiers \texttt{depl0} (resp. \texttt{depl1}) de
  taille 5 qui donne le déplacement de la tête de lecture avec -1 pour
  un déplacement vers la gauche et +1 pour un déplacement vers la
  droite. Par exemple, si la machine lit un 1 sur le ruban et que son
  état courant est 4, alors, la position de la tête de lecture est
  modifiée de la façon suivante : \texttt{pos=pos+depl1[4]}.\\
\item Un tableau d'entiers  \texttt{nextstate0} (resp.  \texttt{nextstate1)} de taille 5 qui donne
  la valeur du prochain état de la machine dans le cas où on lit un 0
  (resp. 1). Par exemple, si la machine lit un 1 sur le ruban et que
  son état courant est 2, alors, le prochain état sera l'entier
  contenu dans  \texttt{nextstate1[2]} (\texttt{cstate=nexstate1[2]}). Attention, il y a un élément du tableau
  \texttt{nextstate0} ou \texttt{nextstate1} qui est égal à -1 qui
  arrête la machine.\\
\end{itemize}
Pour tester l'algorithme, on prendra la machine de Turing suivante :
\begin{itemize}
\item \texttt{write0=\{1,1,1,1,1\}}
\item \texttt{write1=\{0,1,0,0,0\}}
\item \texttt{depl0=\{1,1,1,1,-1\}}
\item \texttt{depl1=\{-1,-1,-1,-1,1\}}
\item \texttt{nextstate0=\{1,2,3,4,3\}}
\item \texttt{nextstate1=\{-1,0,1,2,4\}}
\end{itemize}

\begin{solution}
%\begin{algorithm}[h!]
%\caption{D\'etermination d'un nombre d'occurences d'un entier dans une saisie}
%\label{algo_cm}
\begin{algorithmic}[1]
\REQUIRE{write0,write1,depl0,depl1,nexstate0,nexstate1 : tableaux d'entiers}
\ENSURE{compte : entier, nombre de déplacement}
\\
{\bf Donn\'ees locales : } pos,cstate : entiers ; ruban[] : tableau d'entiers
\\
\STATE pos $\leftarrow 50$
\STATE cstate $\leftarrow 0$
\STATE compte $\leftarrow 0$
\STATE Initialise ruban avec des zéros
\WHILE{cstate $\neq -1$}
\IF{ruban[pos] $=0$}
\STATE ruban[pos] $\leftarrow$ write0[cstate]
\STATE pos $\leftarrow$ pos + depl0[cstate]
\STATE cstate $\leftarrow$ nextstate0[cstate]
\ELSE
\STATE ruban[pos] $\leftarrow$ write1[cstate]
\STATE pos $\leftarrow$ pos + depl1[cstate]
\STATE cstate $\leftarrow$ nextstate1[cstate]
\ENDIF
\STATE compte=compte+1
\ENDWHILE
\end{algorithmic}
%\end{algorithm}
\end{solution}
\subsubsection{Visibilité des variables et appels à fonctions}
%\paragraph{Visibilité des variables}


\exercice On considère le programe suivant :

\begin{verbatim}
#include <stdio.h>

int chose(int a);
int machin();

int chose(int a)
{
  return a+17+machin();
}

int machin()
{
  int a=-1;
  return a;
}

int main()
{
  int a=1;
  a=chose(a);
  printf("%d\n", a);
}
\end{verbatim}

Que se passse-t-il si l'on enlève les déclarations des fonctions \texttt{chose}
et \texttt{machin} ? Qu'affiche le programme ?

\begin{solution}
Rien puisque les fonctions sont définies avant le main.\\
Le programme affiche 17.
\end{solution}

\exercice On considère le programe suivant :

\begin{verbatim}
#include <stdio.h>
int a = 27;

int chose(int a);
int machin();

int chose(int a)
{
  return a+17+machin();
}

int machin()
{
  return a;
}

int main()
{
  int a=1;
  a=chose(a);
  printf("%d\n", a);
}
\end{verbatim}

Qu'affiche le programme ? 

\begin{solution}
Le programme affiche 45. Le a du main n'est pas le a défini en global.
\end{solution}


\exercice Définissez l'affichage
produit par l'exécution du programme. Expliquez.
\begin{verbatim}
#include <stdio.h>

int nb = 3;
//============================================================

void mal_ecrit_1 (int nb)
{
  printf ("nb mal_ecrit_1 = %d\n",nb++);
  {
    int nb = 14;
    printf ("nb mal_ecrit_1 = %d\n",nb);
  }
  printf ("nb mal_ecrit_1 = %d\n",nb);
}
//============================================================

int mal_ecrit_2 (int x, int y)
{
  printf ("nb mal_ecrit_2 = %d\n",x + nb);
  printf ("nb mal_ecrit_2 = %d\n",y + nb);
  return (nb *= 0);
}
//============================================================

int main(void)
{
    int x = 3;
    int y = 6;
    
    printf ("nb main = %d\n",nb);
    mal_ecrit_1(nb);
    printf ("nb main = %d\n",nb);
    printf("resultat de mal_ecrit_2 = %d\n",mal_ecrit_2(y,x));
    printf ("nb = %d\n",nb);
    
    return 0;
}
\end{verbatim}

\begin{solution}
nb main = 3 \\
nb mal\_ecrit\_1 = 3 incrémentation post-fixée donc sans effet immédiat.\\
nb mal\_ecrit\_1 = 14 car nb est une variable locale au bloc d'instructions.\\
nb mal\_ecrit\_1 = 4 car nb a été augmentée préalablement.\\
nb main = 3 car nb est la variable globale et elle n'a pas été affectée par
le premier appel de fonction (passage par valeur, donc copie de la variable)\\
nb mal\_ecrit\_2 = 6.\\
nb mal\_ecrit\_2 = 9.\\
resultat de mal\_ecrit\_2 = 0. La variable globale nb est annulée et c'est la
valeur de retour de ce second appel de fonction. \\
nb = 0 car la variable globale a été modifiée par l'appel de la seconde fonction.
\end{solution}


\subsubsection{Les Pointeurs}

\exercice

Analyser le programme suivant et donner la suite des affichages produits (on choisira arbitrairement les adresses avec des entiers supérieurs à 1000): 

\begin{verbatim}
#include <stdio.h> 

int main (void) { 
  int a, b; 
  int *p, *q; 
  a = 3; b = 4; 
  printf("a = %d, adresse de a = %p,", a, &a); 
  printf("b = %d; adresse de b = %p\n",b, &b); 
  p = &a; q = &b; 
  printf("p = %p, valeur pointee par p = %d,", p, *p); 
  printf("q = %p, valeur pointee par q = %d\n",q, *q); 
  *p += 1; *q += 1; 
  printf("a = %d, b = %d\n", a, b); 
  p = q; 
  printf("p = %p, valeur pointee par p = %d,", p, *p); 
  printf("q = %p, valeur pointee par q = %d\n",q, *q); 
  *p += 10; 
  printf("a = %d, b = %d\n", a, b); 
  return 0; 
} 
\end{verbatim}


\begin{solution}
Exécution :\\
a = 3, adresse de a = 0xbffff814, b = 4 ; adresse de b = 0xbffff810\\ 
p = 0xbffff814, valeur pointee par p = 3, q = 0xbffff810, valeur pointee par q = 4\\ 
a = 4, b = 5\\ 
p = 0xbffff810, valeur pointee par p = 5, q = 0xbffff810, valeur pointee par q = 5\\ 
a = 4, b = 15 
\end{solution}





\exercice

Dans cet exercice, on se propose d'écrire pas-à-pas un programme. Tout doit être fait dans la 
fonction principale. 
\begin{itemize}
\item Déclarer un entier \textbf{i} et un pointeur sur un entier \textbf{p}. 
\item Affecter la valeur 5 à \textbf{i}. 
\item Afficher la valeur de \textbf{i}, et celle de l'adresse de \textbf{i}. 
\item Faire pointer \textbf{p} à l'adresse de \textbf{i}. 
\item Que contient alors l'expression \textbf{*p} ? 
\item Déclarer un nouveau pointeur sur entier \textbf{q} et le faire pointer à la même adresse que \textbf{p}. 
\item Afficher les expressions du programme contenant la valeur 5, ainsi que leur adresse respective. 
\item Augmenter de 2 façons différentes la valeur de \textbf{i} de 2 sans passer par l'intermédiaire de \textbf{i}.
\end{itemize}


\begin{solution}
\begin{verbatim}
#include <stdio.h> 

int main (void) { 
int i; 
int *p, *q; 

i = 5; 
printf("i=%d, adresse de i=%p\n", i, &i); 
// i=5, adresse de i=0xbffff820 

p = &i; 
printf("valeur contenue a l'adresse de p = %d\n", *p); 
// valeur contenue a l'adresse de p = 5 

q = p; 
printf("i=%d, *p=%d, *q=%d\n", i, *p, *q); 
// i=5, *p=5, *q=5 

*p += 2; 
printf("nouvelle valeur de i(1) = %d\n", i); 
// nouvelle valeur de i(1) = 7 

*q += 2; 
printf("nouvelle valeur de i(2) = %d\n", i); 
// nouvelle valeur de i(2) = 9 

return 0; 
} 
\end{verbatim}
\end{solution}




\exercice

Si i et j sont des entiers et p et q, des pointeurs sur des entiers, donner le résultat des 
instructions suivantes : 
\begin{verbatim}
	1) p = &i ; 		2) p = &*&i ;		 3) i = *&*&i ; 
	4) *p = &j;		 5) i = (int)p ;		 6) q = &p ; 
\end{verbatim}


\begin{solution}
1) p pointe sur i.\\ 
2) p pointe sur i, les premiers \&* s'annulent mutuellement\\
3) on met le contenu de i dans i.\\ 
4) on met dans la case pointée par p l'adresse de j, donc i=\&j.\\ 
5) on met l'adresse pointée par p dans i, donc i a pour valeur sa propre adresse.\\ 
6) on fait pointer q sur l'adresse du pointeur p, cad, son emplacement mémoire ; attention, 
cette expression ne permet pas à q de pointer sur la même case mémoire que p.
\end{solution}


\exercice

Trouver l'erreur contenue dans les extraits de programmes suivants : 
\begin{verbatim}
1) int *p ;
   *p = 5 ; 

2) int x = 5 ; 
   int *p = &x ; 
   p = 9 ;  
\end{verbatim}

\begin{solution}
1) il faut faire pointer p sur une case mémoire avant d'affecter 5 on ne sait où.\\
2) on fait pointer p à l'adresse 9, ce qui ne correspond plus à l'adresse de x. 
p ne donne plus accès à l'adresse de x. *p=9 aurait mis la valeur 9 dans x.
\end{solution}

\exercice
On rappelle que si on définit un tableau \texttt{t} de 5 entiers. \texttt{t} désigne l'adresse du premier élément du tableau et \texttt{t+1} est l'adresse du deuxième élément du tableau, etc.

Soit l'extrait code suivant :
\begin{verbatim}
int t[]={4, 3, 2, 1};
int *p1, **p2, *pt[2];
p1 = &t[2];
p2 = &p1;
pt[0] = &t[3];
(*p2)++;
**p2 = 5;
pt[1] = t + 1;
(*p1)++;
t[t[t[2]]]++;
*pt[1]=*(pt[0]-1)+1;
\end{verbatim}
Que vaut le tableau t à la fin de ces instructions ?

\begin{solution}
\begin{tabular}{| c | c | c | c |}
\hline
4 & 3 & 4 & 6 \\
\hline
\end{tabular}
\end{solution}
\newpage

\exercice

\begin{multicols}{2}

On considère le programme \texttt{C} suivant:

\begin{verbatim}
int main ( ) 
{ 
	int a = 1, b = 2, c = 3; 
	int *p1, *p2; 
	p1 = &a; 
	p2 = &c; 
	*p1 = ( *p2 )++; 
	p1 = p2; 
	p2 = &b; 
	*p1 -= *p2; 
	++( *p2 ); 
	*p1 *= *p2; 
	a = ( ++( *p2 ) ) * *p1; 
	p1 = &a; 
	*p2 = *p1 /= *p2 ; 

	return (0);
}
\end{verbatim}

\columnbreak

Remplissez le tableau suivant :\\

\begin{tabular}{|l|c|c|c|c|c|}
	\hline & \texttt{a} & \texttt{b} & \texttt{c} & \texttt{p1} & \texttt{p2} \\
&&&&&\\
	\hline Init &&&&&\\
	\hline \texttt{p1 = \&a;} &&&&&\\
	\hline \texttt{p2 = \&c;} &&&&&\\ 
	\hline \texttt{*p1 = ( *p2 )++;} &&&&&\\ 
	\hline \texttt{p1 = p2;} &&&&&\\
	\hline \texttt{p2 = \&b;} &&&&&\\ 
	\hline \texttt{*p1 -= *p2;} &&&&&\\
	\hline \texttt{++( *p2 );} &&&&&\\
	\hline \texttt{*p1 *= *p2;} &&&&&\\
	\hline \texttt{a = ( ++( *p2 ) ) * *p1;} &&&&&\\
	\hline \texttt{p1 = \&a;} &&&&&\\
	\hline \texttt{*p2 = *p1 /= *p2;} &&&&&\\ 
	\hline
\end{tabular}

\end{multicols}

\begin{solution}
\begin{tabular}{|l|c|c|c|c|c|l|}
	\hline & {a} & {b} & {c} & {p1} & {p2} &\\
	\hline Init 					& 1 & 2 & 3 &  & & \\
	\hline {p1 = \&a;} 			& 1 & 2 & 3 & \&a && \\
	\hline {p2 = \&c;} 			& 1 & 2 & 3 & \&a & \&c &\\
	\hline {*p1 = ( *p2 )++;} 		& 3 & 2 & 4 & \&a & \&c & $\rightarrow$ a = c++;\\
	\hline {p1 = p2;} 			& 3 & 2 & 4 & \&c & \&c &\\
	\hline {p2 = \&b;}			& 3 & 2 & 4 & \&c & \&b &\\
	\hline {*p1 -= *p2;} 			& 3 & 2 & 2 & \&c & \&b & $\rightarrow$ c = c - b;\\
	\hline {++( *p2 );} 			& 3 & 3 & 2 & \&c & \&b & $\rightarrow$ ++b;\\
	\hline {*p1 *= *p2;}			& 3 & 3 & 6 & \&c & \&b & $\rightarrow$ c = c * b;\\ 
	\hline {a = ( ++( *p2 ) ) * *p1;} 	&24& 4 & 6 & \&c & \&b & $\rightarrow$ a = (++b) * c;\\
	\hline {p1 = \&a;} 			&24& 4 & 6 & \&c & \&b &\\
	\hline {*p2 = *p1 /= *p2;} 		& 6 & 6 & 6 & \&c & \&b & $\rightarrow$ b = (a = a / b);\\ 
	\hline
\end{tabular}
\end{solution}


\end{document}